from datetime import datetime, timedelta, tzinfo
from typing import Any, Callable, Dict, List, Optional, Tuple, Type

from nautilus_trader.common.config import NautilusConfig
from nautilus_trader.common.enums import (
    ComponentState,
    ComponentTrigger,
    LogColor,
    LogLevel,
)
from nautilus_trader.core.message import Event, Request, Response
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.model.identifiers import ComponentId, Identifier, TraderId
from nautilus_trader.serialization.base import Serializer

class Logger:
    name: str

    def __init__(self, name: str) -> None: ...
    def debug(self, message: str, color: LogColor = LogColor.NORMAL) -> None: ...
    def info(self, message: str, color: LogColor = LogColor.NORMAL) -> None: ...
    def warning(self, message: str, color: LogColor = LogColor.YELLOW) -> None: ...
    def error(self, message: str, color: LogColor = LogColor.RED) -> None: ...
    def exception(self, message: str, ex: Exception) -> None: ...

class Clock:
    def timer_names(self) -> List[str]: ...
    def timer_count(self) -> int: ...
    def timestamp(self) -> float: ...
    def timestamp_ms(self) -> int: ...
    def timestamp_us(self) -> int: ...
    def timestamp_ns(self) -> int: ...
    def utc_now(self) -> datetime: ...
    def local_now(self, tz: Optional[tzinfo] = None) -> datetime: ...
    def register_default_handler(self, handler: Callable[[Any], None]) -> None: ...
    def set_time_alert(
        self,
        name: str,
        alert_time: datetime,
        callback: Optional[Callable[[Any], None]] = None,
        override: bool = False,
    ) -> None: ...
    def set_time_alert_ns(
        self,
        name: str,
        alert_time_ns: int,
        callback: Optional[Callable[[Any], None]] = None,
    ) -> None: ...
    def set_timer(
        self,
        name: str,
        interval: timedelta,
        start_time: Optional[datetime] = None,
        stop_time: Optional[datetime] = None,
        callback: Optional[Callable[[Any], None]] = None,
    ) -> None: ...
    def set_timer_ns(
        self,
        name: str,
        interval_ns: int,
        start_time_ns: int,
        stop_time_ns: int,
        callback: Optional[Callable[[Any], None]] = None,
    ) -> None: ...
    def cancel_timer(self, name: str) -> None: ...
    def cancel_timers(self) -> None: ...

class TestClock(Clock):
    def set_time(self, to_time_ns: int) -> None: ...
    def advance_time(self, to_time_ns: int, set_time: bool = True) -> List[Any]: ...

class LiveClock(Clock):
    pass

class TimeEvent(Event):
    name: str
    id: UUID4
    ts_event: int
    ts_init: int

    def __init__(
        self,
        name: str,
        event_id: UUID4,
        ts_event: int,
        ts_init: int,
    ) -> None: ...

class TimeEventHandler:
    event: TimeEvent
    def __init__(
        self,
        event: TimeEvent,
        handler: Callable[[TimeEvent], None],
    ) -> None: ...
    def handle(self) -> None: ...

class LogGuard:
    pass

def init_logging(
    trader_id: Optional[TraderId] = None,
    machine_id: Optional[str] = None,
    instance_id: Optional[UUID4] = None,
    level_stdout: LogLevel = LogLevel.INFO,
    level_file: LogLevel = LogLevel.OFF,
    directory: Optional[str] = None,
    file_name: Optional[str] = None,
    file_format: Optional[str] = None,
    component_levels: Optional[Dict[ComponentId, LogLevel]] = None,
    colors: bool = True,
    bypass: bool = False,
    print_config: bool = False,
) -> LogGuard: ...
def is_logging_initialized() -> bool: ...
def set_logging_pyo3(value: bool) -> None: ...

class Component:
    trader_id: Optional[TraderId]
    id: Identifier
    type: Type
    _log: Logger

    def __init__(
        self,
        clock: Clock,
        trader_id: Optional[TraderId] = None,
        component_id: Optional[Identifier] = None,
        component_name: Optional[str] = None,
        msgbus: Optional[Any] = None,
        config: Optional[NautilusConfig] = None,
    ) -> None: ...
    @classmethod
    def fully_qualified_name(cls) -> str: ...
    @property
    def state(self) -> ComponentState: ...
    @property
    def is_initialized(self) -> bool: ...
    @property
    def is_running(self) -> bool: ...
    @property
    def is_stopped(self) -> bool: ...
    @property
    def is_disposed(self) -> bool: ...
    @property
    def is_degraded(self) -> bool: ...
    @property
    def is_faulted(self) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def resume(self) -> None: ...
    def reset(self) -> None: ...
    def dispose(self) -> None: ...
    def degrade(self) -> None: ...
    def fault(self) -> None: ...

class Subscription:
    topic: str
    handler: Callable[[Any], None]
    priority: int

    def __init__(
        self,
        topic: str,
        handler: Callable[[Any], None],
        priority: int = 0,
    ) -> None: ...

class MessageBus:
    trader_id: TraderId
    serializer: Optional[Serializer]
    has_backing: bool
    sent_count: int
    req_count: int
    res_count: int
    pub_count: int

    def __init__(
        self,
        trader_id: TraderId,
        clock: Clock,
        instance_id: Optional[UUID4] = None,
        name: Optional[str] = None,
        serializer: Optional[Serializer] = None,
        database: Optional[Any] = None,
        config: Optional[Any] = None,
    ) -> None: ...
    def endpoints(self) -> List[str]: ...
    def topics(self) -> List[str]: ...
    def subscriptions(self, pattern: Optional[str] = None) -> List[Any]: ...
    def has_subscribers(self, pattern: Optional[str] = None) -> bool: ...
    def is_subscribed(self, topic: str, handler: Callable[[Any], None]) -> bool: ...
    def is_pending_request(self, request_id: UUID4) -> bool: ...
    def is_streaming_type(self, cls: Type) -> bool: ...
    def dispose(self) -> None: ...
    def register(self, endpoint: str, handler: Callable[[Any], None]) -> None: ...
    def deregister(self, endpoint: str, handler: Callable[[Any], None]) -> None: ...
    def add_streaming_type(self, cls: Type) -> None: ...
    def send(self, endpoint: str, msg: Any) -> None: ...
    def request(self, endpoint: str, request: Request) -> None: ...
    def response(self, response: Response) -> None: ...
    def subscribe(
        self,
        topic: str,
        handler: Callable[[Any], None],
        priority: int = 0,
    ) -> None: ...
    def unsubscribe(self, topic: str, handler: Callable[[Any], None]) -> None: ...
    def publish(self, topic: str, msg: Any, external_pub: bool = True) -> None: ...

class Throttler:
    name: str
    limit: int
    interval: timedelta
    is_limiting: bool
    recv_count: int
    sent_count: int

    def __init__(
        self,
        name: str,
        limit: int,
        interval: timedelta,
        clock: Clock,
        output_send: Callable[[Any], None],
        output_drop: Optional[Callable[[Any], None]] = None,
    ) -> None: ...
    @property
    def qsize(self) -> int: ...
    def reset(self) -> None: ...
    def used(self) -> float: ...
    def send(self, msg: Any) -> None: ...

class ComponentFSMFactory:
    @staticmethod
    def get_state_transition_table() -> (
        Dict[Tuple[ComponentState, ComponentTrigger], ComponentState]
    ): ...

def log_color_from_str(value: str) -> LogColor: ...
def log_color_to_str(value: LogColor) -> str: ...
def log_level_from_str(value: str) -> LogLevel: ...
def log_level_to_str(value: LogLevel) -> str: ...
def log_header(
    trader_id: TraderId,
    machine_id: str,
    instance_id: UUID4,
    component: str,
) -> None: ...
def log_sysinfo(component: str) -> None: ...
def component_state_from_str(value: str) -> ComponentState: ...
def component_state_to_str(value: ComponentState) -> str: ...
def component_trigger_from_str(value: str) -> ComponentTrigger: ...
def component_trigger_to_str(value: ComponentTrigger) -> str: ...
