from asyncio import AbstractEventLoop
from concurrent.futures import Executor
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type, Union

from nautilus_trader.cache.base import CacheFacade
from nautilus_trader.common.component import Clock, Component, Logger, MessageBus
from nautilus_trader.common.config import ActorConfig, ImportableActorConfig
from nautilus_trader.core.data import Data
from nautilus_trader.core.message import Event
from nautilus_trader.core.model import BookType, PositionSide
from nautilus_trader.core.uuid import UUID4
from nautilus_trader.indicators.base.indicator import Indicator
from nautilus_trader.model.book import OrderBook
from nautilus_trader.model.data import (
    Bar,
    BarType,
    DataType,
    InstrumentClose,
    InstrumentStatus,
    QuoteTick,
    TradeTick,
)
from nautilus_trader.model.greeks import GreeksData, PortfolioGreeks
from nautilus_trader.model.identifiers import ClientId, InstrumentId, StrategyId, Venue
from nautilus_trader.model.instruments.base import Instrument
from nautilus_trader.model.instruments.synthetic import SyntheticInstrument
from nautilus_trader.portfolio.base import PortfolioFacade

class Actor(Component):
    portfolio: PortfolioFacade
    config: ActorConfig
    clock: Clock
    log: Logger
    msgbus: MessageBus
    cache: CacheFacade

    def __init__(self, config: Optional[ActorConfig] = None) -> None: ...
    def to_importable_config(self) -> ImportableActorConfig: ...
    def indicators_initialized(self) -> bool: ...

    # Abstract methods
    def on_save(self) -> Dict[str, Any]: ...
    def on_load(self, state: Dict[str, Any]) -> None: ...
    def on_start(self) -> None: ...
    def on_stop(self) -> None: ...
    def on_resume(self) -> None: ...
    def on_reset(self) -> None: ...
    def on_dispose(self) -> None: ...
    def on_degrade(self) -> None: ...
    def on_fault(self) -> None: ...
    def on_instrument_status(self, data: InstrumentStatus) -> None: ...
    def on_instrument_close(self, data: InstrumentClose) -> None: ...
    def on_instrument(self, instrument: Instrument) -> None: ...
    def on_order_book_deltas(self, deltas: Any) -> None: ...
    def on_order_book(self, order_book: OrderBook) -> None: ...
    def on_quote_tick(self, tick: QuoteTick) -> None: ...
    def on_trade_tick(self, tick: TradeTick) -> None: ...
    def on_bar(self, bar: Bar) -> None: ...
    def on_data(self, data: Data) -> None: ...
    def on_signal(self, signal: Data) -> None: ...
    def on_historical_data(self, data: Data) -> None: ...
    def on_event(self, event: Event) -> None: ...

    # Registration
    def register_base(
        self,
        portfolio: PortfolioFacade,
        msgbus: MessageBus,
        cache: CacheFacade,
        clock: Clock,
    ) -> None: ...
    def register_executor(
        self, loop: AbstractEventLoop, executor: Executor
    ) -> None: ...
    def register_warning_event(self, event: Type[Event]) -> None: ...
    def deregister_warning_event(self, event: Type[Event]) -> None: ...
    def register_indicator_for_quote_ticks(
        self, instrument_id: InstrumentId, indicator: Indicator
    ) -> None: ...
    def register_indicator_for_trade_ticks(
        self, instrument_id: InstrumentId, indicator: Indicator
    ) -> None: ...
    def register_indicator_for_bars(
        self, bar_type: BarType, indicator: Indicator
    ) -> None: ...

    # Actor commands
    def save(self) -> Dict[str, Any]: ...
    def load(self, state: Dict[str, Any]) -> None: ...
    def add_synthetic(self, synthetic: SyntheticInstrument) -> None: ...
    def update_synthetic(self, synthetic: SyntheticInstrument) -> None: ...
    def queue_for_executor(
        self,
        func: Callable[..., Any],
        args: Optional[Tuple] = None,
        kwargs: Optional[Dict] = None,
    ) -> Any: ...
    def run_in_executor(
        self,
        func: Callable[..., Any],
        args: Optional[Tuple] = None,
        kwargs: Optional[Dict] = None,
    ) -> Any: ...
    def queued_task_ids(self) -> List[Any]: ...
    def active_task_ids(self) -> List[Any]: ...
    def has_queued_tasks(self) -> bool: ...
    def has_active_tasks(self) -> bool: ...
    def has_any_tasks(self) -> bool: ...
    def cancel_task(self, task_id: Any) -> None: ...
    def cancel_all_tasks(self) -> None: ...

    # Subscriptions
    def subscribe_data(
        self, data_type: DataType, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_instruments(
        self, venue: Venue, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_instrument(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_order_book_deltas(
        self,
        instrument_id: InstrumentId,
        book_type: BookType = BookType.L2_MBP,
        depth: int = 0,
        kwargs: Optional[Dict] = None,
        client_id: Optional[ClientId] = None,
        managed: bool = True,
        pyo3_conversion: bool = False,
    ) -> None: ...
    def subscribe_order_book_at_interval(
        self,
        instrument_id: InstrumentId,
        book_type: BookType = BookType.L2_MBP,
        depth: int = 0,
        interval_ms: int = 1000,
        kwargs: Optional[Dict] = None,
        client_id: Optional[ClientId] = None,
        managed: bool = True,
    ) -> None: ...
    def subscribe_quote_ticks(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_trade_ticks(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_bars(
        self,
        bar_type: BarType,
        client_id: Optional[ClientId] = None,
        await_partial: bool = False,
    ) -> None: ...
    def subscribe_instrument_status(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def subscribe_instrument_close(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_data(
        self, data_type: DataType, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_instruments(
        self, venue: Venue, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_instrument(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_order_book_deltas(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_order_book_at_interval(
        self,
        instrument_id: InstrumentId,
        interval_ms: int = 1000,
        client_id: Optional[ClientId] = None,
    ) -> None: ...
    def unsubscribe_quote_ticks(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_trade_ticks(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_bars(
        self, bar_type: BarType, client_id: Optional[ClientId] = None
    ) -> None: ...
    def unsubscribe_instrument_status(
        self, instrument_id: InstrumentId, client_id: Optional[ClientId] = None
    ) -> None: ...
    def publish_data(self, data_type: DataType, data: Data) -> None: ...
    def publish_signal(
        self, name: str, value: Union[int, float, str], ts_event: int = 0
    ) -> None: ...
    def subscribe_signal(self, name: str = "") -> None: ...

    # Requests
    def request_data(
        self,
        data_type: DataType,
        client_id: ClientId,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_instrument(
        self,
        instrument_id: InstrumentId,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_instruments(
        self,
        venue: Venue,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_order_book_snapshot(
        self,
        instrument_id: InstrumentId,
        limit: int,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_quote_ticks(
        self,
        instrument_id: InstrumentId,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_trade_ticks(
        self,
        instrument_id: InstrumentId,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_bars(
        self,
        bar_type: BarType,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def request_aggregated_bars(
        self,
        bar_types: List[BarType],
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        update_existing_subscriptions: bool = False,
        include_external_data: bool = False,
        client_id: Optional[ClientId] = None,
        callback: Optional[Callable[[UUID4], None]] = None,
    ) -> UUID4: ...
    def is_pending_request(self, request_id: UUID4) -> bool: ...
    def has_pending_requests(self) -> bool: ...
    def pending_requests(self) -> Set[UUID4]: ...

    # Handlers
    def handle_instrument(self, instrument: Instrument) -> None: ...
    def handle_instruments(self, instruments: List[Instrument]) -> None: ...
    def handle_order_book(self, order_book: OrderBook) -> None: ...
    def handle_order_book_deltas(self, deltas: Any) -> None: ...
    def handle_quote_tick(self, tick: QuoteTick) -> None: ...
    def handle_quote_ticks(self, ticks: List[QuoteTick]) -> None: ...
    def handle_trade_tick(self, tick: TradeTick) -> None: ...
    def handle_trade_ticks(self, ticks: List[TradeTick]) -> None: ...
    def handle_bar(self, bar: Bar) -> None: ...
    def handle_bars(self, bars: List[Bar]) -> None: ...
    def handle_data(self, data: Data) -> None: ...
    def handle_signal(self, signal: Data) -> None: ...
    def handle_instrument_status(self, data: InstrumentStatus) -> None: ...
    def handle_instrument_close(self, data: InstrumentClose) -> None: ...
    def handle_historical_data(self, data: Data) -> None: ...
    def handle_event(self, event: Event) -> None: ...

    # Greeks
    def instrument_greeks_data(self, instrument_id: InstrumentId) -> GreeksData: ...
    def portfolio_greeks(
        self,
        underlying: str = "",
        venue: Optional[Venue] = None,
        instrument_id: Optional[InstrumentId] = None,
        strategy_id: Optional[StrategyId] = None,
        side: PositionSide = PositionSide.NO_POSITION_SIDE,
    ) -> PortfolioGreeks: ...
