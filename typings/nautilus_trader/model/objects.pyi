from decimal import Decimal
from typing import ClassVar, Dict, Optional, Union

from nautilus_trader.core.model import CurrencyType
from nautilus_trader.model.identifiers import InstrumentId

_int64_t = int
_uint64_t = int
Number = Union[int, float, str, Decimal]

class Quantity:
    QUANTITY_MAX: ClassVar[int]
    QUANTITY_MIN: ClassVar[int]
    FIXED_PRECISION: ClassVar[int]
    FIXED_SCALAR: ClassVar[int]

    def __init__(self, value: Number, precision: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __add__(self, other: object) -> Union[Decimal, float]: ...
    def __radd__(self, other: object) -> Union[Decimal, float]: ...
    def __sub__(self, other: object) -> Union[Decimal, float]: ...
    def __rsub__(self, other: object) -> Union[Decimal, float]: ...
    def __mul__(self, other: object) -> Union[Decimal, float]: ...
    def __rmul__(self, other: object) -> Union[Decimal, float]: ...
    def __truediv__(self, other: object) -> Union[Decimal, float]: ...
    def __rtruediv__(self, other: object) -> Union[Decimal, float]: ...
    def __floordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __rfloordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __mod__(self, other: object) -> Union[Decimal, float]: ...
    def __rmod__(self, other: object) -> Union[Decimal, float]: ...
    def __neg__(self) -> Decimal: ...
    def __pos__(self) -> Decimal: ...
    def __abs__(self) -> Decimal: ...
    def __round__(self, ndigits: Optional[int] = None) -> Decimal: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def raw(self) -> _uint64_t: ...
    @property
    def precision(self) -> int: ...
    @staticmethod
    def zero(precision: int = 0) -> Quantity: ...
    @staticmethod
    def from_raw(raw: _int64_t, precision: int) -> Quantity: ...
    @staticmethod
    def from_str(value: str) -> Quantity: ...
    @staticmethod
    def from_int(value: int) -> Quantity: ...
    @staticmethod
    def raw_to_f64(raw: _uint64_t) -> float: ...
    def to_formatted_str(self) -> str: ...
    def as_decimal(self) -> Decimal: ...
    def as_double(self) -> float: ...

class Price:
    PRICE_MAX: ClassVar[int]
    PRICE_MIN: ClassVar[int]
    FIXED_PRECISION: ClassVar[int]
    FIXED_SCALAR: ClassVar[int]

    def __init__(self, value: Number, precision: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __add__(self, other: object) -> Union[Decimal, float]: ...
    def __radd__(self, other: object) -> Union[Decimal, float]: ...
    def __sub__(self, other: object) -> Union[Decimal, float]: ...
    def __rsub__(self, other: object) -> Union[Decimal, float]: ...
    def __mul__(self, other: object) -> Union[Decimal, float]: ...
    def __rmul__(self, other: object) -> Union[Decimal, float]: ...
    def __truediv__(self, other: object) -> Union[Decimal, float]: ...
    def __rtruediv__(self, other: object) -> Union[Decimal, float]: ...
    def __floordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __rfloordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __mod__(self, other: object) -> Union[Decimal, float]: ...
    def __rmod__(self, other: object) -> Union[Decimal, float]: ...
    def __neg__(self) -> Decimal: ...
    def __pos__(self) -> Decimal: ...
    def __abs__(self) -> Decimal: ...
    def __round__(self, ndigits: Optional[int] = None) -> Decimal: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def raw(self) -> _int64_t: ...
    @property
    def precision(self) -> int: ...
    @staticmethod
    def from_raw(raw: _int64_t, precision: int) -> Price: ...
    @staticmethod
    def from_str(value: str) -> Price: ...
    @staticmethod
    def from_int(value: int) -> Price: ...
    def to_formatted_str(self) -> str: ...
    def as_decimal(self) -> Decimal: ...
    def as_double(self) -> float: ...

class Currency:
    def __init__(
        self,
        code: str,
        precision: int,
        iso4217: int,
        name: str,
        currency_type: CurrencyType,
    ) -> None: ...
    def __eq__(self, other: Optional[Currency]) -> bool: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def code(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def precision(self) -> int: ...
    @property
    def iso4217(self) -> int: ...
    @property
    def currency_type(self) -> CurrencyType: ...
    @staticmethod
    def register(currency: Currency, overwrite: bool = False) -> None: ...
    @staticmethod
    def from_internal_map(code: str) -> Optional[Currency]: ...
    @staticmethod
    def from_str(code: str, strict: bool = False) -> Optional[Currency]: ...
    @staticmethod
    def is_fiat(code: str) -> bool: ...
    @staticmethod
    def is_crypto(code: str) -> bool: ...

class Money:
    MONEY_MAX: ClassVar[int]
    MONEY_MIN: ClassVar[int]
    FIXED_PRECISION: ClassVar[int]
    FIXED_SCALAR: ClassVar[int]

    def __init__(self, value: Optional[Number], currency: Currency) -> None: ...
    def __eq__(self, other: Money) -> bool: ...
    def __lt__(self, other: Money) -> bool: ...
    def __le__(self, other: Money) -> bool: ...
    def __gt__(self, other: Money) -> bool: ...
    def __ge__(self, other: Money) -> bool: ...
    def __add__(self, other: object) -> Union[Decimal, float]: ...
    def __radd__(self, other: object) -> Union[Decimal, float]: ...
    def __sub__(self, other: object) -> Union[Decimal, float]: ...
    def __rsub__(self, other: object) -> Union[Decimal, float]: ...
    def __mul__(self, other: object) -> Union[Decimal, float]: ...
    def __rmul__(self, other: object) -> Union[Decimal, float]: ...
    def __truediv__(self, other: object) -> Union[Decimal, float]: ...
    def __rtruediv__(self, other: object) -> Union[Decimal, float]: ...
    def __floordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __rfloordiv__(self, other: object) -> Union[Decimal, float]: ...
    def __mod__(self, other: object) -> Union[Decimal, float]: ...
    def __rmod__(self, other: object) -> Union[Decimal, float]: ...
    def __neg__(self) -> Decimal: ...
    def __pos__(self) -> Decimal: ...
    def __abs__(self) -> Decimal: ...
    def __round__(self, ndigits: Optional[int] = None) -> Decimal: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @property
    def raw(self) -> _int64_t: ...
    @property
    def currency(self) -> Currency: ...
    @staticmethod
    def from_raw(raw: _int64_t, currency: Currency) -> Money: ...
    @staticmethod
    def from_str(value: str) -> Money: ...
    def to_formatted_str(self) -> str: ...
    def as_decimal(self) -> Decimal: ...
    def as_double(self) -> float: ...

class AccountBalance:
    total: Money
    locked: Money
    free: Money
    currency: Currency

    def __init__(self, total: Money, locked: Money, free: Money) -> None: ...
    def __eq__(self, other: AccountBalance) -> bool: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_dict(values: Dict[str, object]) -> AccountBalance: ...
    def to_dict(self) -> Dict[str, object]: ...

class MarginBalance:
    initial: Money
    maintenance: Money
    currency: Currency
    instrument_id: Optional[InstrumentId]

    def __init__(
        self,
        initial: Money,
        maintenance: Money,
        instrument_id: Optional[InstrumentId] = None,
    ) -> None: ...
    def __eq__(self, other: MarginBalance) -> bool: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_dict(values: Dict[str, object]) -> MarginBalance: ...
    def to_dict(self) -> Dict[str, object]: ...
